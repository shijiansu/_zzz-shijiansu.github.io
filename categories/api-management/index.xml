<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shijian Homepage – API Management</title><link>/categories/api-management/</link><description>Recent content in API Management on Shijian Homepage</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 16 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/api-management/index.xml" rel="self" type="application/rss+xml"/><item><title>Topics: Practical advice for designing REST APIs</title><link>/topics/api-management/design-restful-api/practical-advice-for-designing-rest-apis/</link><pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate><guid>/topics/api-management/design-restful-api/practical-advice-for-designing-rest-apis/</guid><description>
&lt;blockquote>
&lt;p>&lt;a href="https://betterprogramming.pub/22-best-practices-to-take-your-api-design-skills-to-the-next-level-65569b200b9">https://betterprogramming.pub/22-best-practices-to-take-your-api-design-skills-to-the-next-level-65569b200b9&lt;/a> | 2021-04-16&lt;/p>
&lt;/blockquote>
&lt;h2 id="first-some-terminology">First, Some Terminology&lt;/h2>
&lt;p>Any API design follows something called &lt;code>Resource Oriented Design&lt;/code> It consists of three key concepts&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Resource:&lt;/strong> A resource is a piece of data, For example, &lt;strong>a User&lt;/strong>.&lt;/li>
&lt;li>&lt;strong>Collection:&lt;/strong> A group of resources is called a collection. Example: &lt;strong>A list of users&lt;/strong>&lt;/li>
&lt;li>&lt;strong>URL:&lt;/strong> Identifies the location of resource or collection. Example: &lt;code>/user&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="1-use-kebab-case-for-urls">1. Use kebab-case for URLs&lt;/h2>
&lt;p>For example, if you want to get the list of orders.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong> &lt;code>/systemOrders or /system_orders&lt;/code>&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>/system-orders&lt;/code>&lt;/p>
&lt;h2 id="2-use-camelcase-for-parameters">2. Use camelCase for Parameters&lt;/h2>
&lt;p>For example, if you want to get products from a particular shop.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong> &lt;code>/system-orders/{order_id} or /system-orders/{OrderId}&lt;/code>&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>/system-orders/{orderId}&lt;/code>&lt;/p>
&lt;h2 id="3-plural-name-to-point-to-a-collection">3. Plural Name to Point to a Collection&lt;/h2>
&lt;p>If you want to get all the users of a system.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong> &lt;code>GET /user or GET /User&lt;/code>&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>GET /users&lt;/code>&lt;/p>
&lt;h2 id="4-url-starts-with-a-collection-and-ends-with-an-identifier">4. URL Starts With a Collection and Ends With an Identifier&lt;/h2>
&lt;p>If want to keep the concept singular and consistent.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong> &lt;code>GET /shops/:shopId/category/:categoryId/price&lt;/code>&lt;/p>
&lt;p>This is bad because it’s pointing to a property instead of a resource.&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>GET /shops/:shopId/ or GET /category/:categoryId&lt;/code>&lt;/p>
&lt;h2 id="5-keep-verbs-out-of-your-resource-url">5. Keep Verbs Out of Your Resource URL&lt;/h2>
&lt;p>Don’t use verbs to express your intention in the URL. Instead, use proper HTTP methods to describe the operation.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong> &lt;code>POST /updateuser/{userId} or GET /getusers&lt;/code>&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>PUT /user/{userId}&lt;/code>&lt;/p>
&lt;h2 id="6-use-verbs-for-non-resource-url">6. Use Verbs for Non-Resource URL&lt;/h2>
&lt;p>You have an endpoint that returns nothing but an operation. In this case, you can use verbs. For example, if you want to resend the alert to a user.&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>POST /alerts/245743/resend&lt;/code>&lt;/p>
&lt;p>Keep in mind that these are not our CRUD operations. Rather, these are considered functions that do a specific job in our system.&lt;/p>
&lt;h2 id="7-use-camelcase-for-json-property">7. Use camelCase for JSON property&lt;/h2>
&lt;p>If you’re building a system in which the request body or response is JSON, the property names should be in &lt;code>camelCase&lt;/code>&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">{
user_name: &amp;#34;Mohammad Faisal&amp;#34;
user_id: &amp;#34;1&amp;#34;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Good:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">{
userName: &amp;#34;Mohammad Faisal&amp;#34;
userId: &amp;#34;1&amp;#34;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="8-monitoring">8. Monitoring&lt;/h2>
&lt;p>RESTful HTTP services MUST implement the &lt;code>/health&lt;/code> and &lt;code>/version&lt;/code> and &lt;code>/metrics&lt;/code> API endpoints. They will provide the following info.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>/health&lt;/strong>: Respond to requests to &lt;code>/health&lt;/code> with a &lt;code>200 OK&lt;/code> status code.&lt;/li>
&lt;li>&lt;strong>/version&lt;/strong>: Respond to request to &lt;code>/version&lt;/code> with the version number.&lt;/li>
&lt;li>&lt;strong>/metrics&lt;/strong>: This endpoint will provide various metrics like average response time.&lt;/li>
&lt;/ul>
&lt;p>&lt;code>/debug&lt;/code> and &lt;code>/status&lt;/code> endpoints are also highly recommended.&lt;/p>
&lt;h2 id="9-dont-use-table_name-for-the-resource-name">9. Don’t Use table_name for the Resource Name&lt;/h2>
&lt;p>Don’t just use the table name as your resource name. In the long run, this kind of laziness can be harmful.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong> &lt;code>product_order&lt;/code>&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>product-orders&lt;/code>&lt;/p>
&lt;p>This is because exposing the underlying architecture is not your purpose.&lt;/p>
&lt;h2 id="10-use-api-design-tools">10. Use API Design Tools&lt;/h2>
&lt;p>There are many good API design tools for good documentation, such as:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://apiblueprint.org/">API Blueprint&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://swagger.io/">Swagger&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Having good and detailed documentation results in a great user experience for your API consumers.&lt;/p>
&lt;h2 id="11-use-simple-ordinal-number-as-version">11. Use Simple Ordinal Number as Version&lt;/h2>
&lt;p>Always use versioning for the API and move it all the way to the left so that it has the highest scope. The version number should be &lt;code>v1&lt;/code>, &lt;code>v2&lt;/code> etc.&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>http://api.domain.com/v1/shops/3/products&lt;/code>&lt;/p>
&lt;p>Always use versioning in your API because if the API is being used by external entities, changing the endpoint can break their functionality.&lt;/p>
&lt;h2 id="12-include-total-number-of-resources-in-your-response">12. Include Total Number of Resources in Your Response&lt;/h2>
&lt;p>If an API returns a list of objects always include the total number of resources in the response. You can use the &lt;code>total&lt;/code> property for this.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">{
users: [
...
]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Good:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">{
users: [
...
], total: 34
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="13-accept-limit-and-offset-parameters">13. Accept limit and offset Parameters&lt;/h2>
&lt;p>Always accept &lt;code>limit&lt;/code> and &lt;code>offset&lt;/code> parameters in &lt;code>GET&lt;/code> operations.&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong> &lt;code>GET /shops?offset=5&amp;amp;limit=5&lt;/code>&lt;/p>
&lt;p>This is because it’s necessary for pagination on the front end.&lt;/p>
&lt;h2 id="14-take-fields-query-parameter">14. Take fields Query Parameter&lt;/h2>
&lt;p>The amount of data being returned should also be taken into consideration. Add a &lt;code>fields&lt;/code> parameter to expose only the required fields from your API.&lt;/p>
&lt;h3 id="example">Example&lt;/h3>
&lt;p>Only return the name, address, and contact of the shops.&lt;/p>
&lt;p>&lt;code>GET /shops?fields=id,name,address,contact&lt;/code>&lt;/p>
&lt;p>It also helps to reduce the response size in some cases.&lt;/p>
&lt;h2 id="15-dont-pass-authentication-tokens-in-url">15. Don’t Pass Authentication Tokens in URL&lt;/h2>
&lt;p>This is a very bad practice because often URLs are logged and the authentication token will also be logged unnecessarily.&lt;/p>
&lt;p>&lt;strong>Bad:&lt;/strong> &lt;code>GET /shops/123?token=some_kind_of_authenticaiton_token&lt;/code>&lt;/p>
&lt;p>&lt;strong>Good:&lt;/strong>&lt;/p>
&lt;p>Instead, pass them with the header:&lt;/p>
&lt;p>&lt;code>Authorization: Bearer xxxxxx, Extra yyyyy&lt;/code>&lt;/p>
&lt;p>Also, authorization tokens should be short-lived&lt;/p>
&lt;h2 id="16-validate-the-content-type">16. Validate the Content-Type&lt;/h2>
&lt;p>The server should not assume the content type. For example, if you accept &lt;code>application/x-www-form-urlencoded&lt;/code> then an attacker can create a form and trigger a simple POST request.&lt;/p>
&lt;p>So, always validate the &lt;code>content-type&lt;/code> and if you want to go with a default one use &lt;code>content-type: application/json&lt;/code>&lt;/p>
&lt;h2 id="17-use-http-methods-for-crud-functions">17. Use HTTP Methods for CRUD Functions&lt;/h2>
&lt;p>HTTP methods serve the purpose of explaining CRUD functionality.&lt;/p>
&lt;ul>
&lt;li>&lt;code>GET&lt;/code>: To retrieve a representation of a resource.&lt;/li>
&lt;li>&lt;code>POST&lt;/code>: To create new resources and sub-resources.&lt;/li>
&lt;li>&lt;code>PUT&lt;/code>: To update existing resources.&lt;/li>
&lt;li>&lt;code>PATCH&lt;/code>: To update existing resources. It only updates the fields that were supplied, leaving the others alone&lt;/li>
&lt;li>&lt;code>DELETE&lt;/code>: To delete existing resources.&lt;/li>
&lt;/ul>
&lt;h2 id="18-use-the-relation-in-the-url-for-nested-resources">18. Use the Relation in the URL For Nested Resources&lt;/h2>
&lt;p>Some practical examples are:&lt;/p>
&lt;ul>
&lt;li>&lt;code>GET /shops/2/products&lt;/code> : Get the list of all products from shop 2.&lt;/li>
&lt;li>&lt;code>GET /shops/2/products/31&lt;/code>: Get the details of product 31, which belongs to shop 2.&lt;/li>
&lt;li>&lt;code>DELETE /shops/2/products/31&lt;/code> , should delete product 31, which belongs to shop 2.&lt;/li>
&lt;li>&lt;code>PUT /shops/2/products/31&lt;/code> , should update the info of product 31, Use PUT on resource-URL only, not the collection.&lt;/li>
&lt;li>&lt;code>POST /shops&lt;/code> , should create a new shop and return the details of the new shop created. Use POST on collection-URLs.&lt;/li>
&lt;/ul>
&lt;h2 id="19-cors">19. CORS&lt;/h2>
&lt;p>Do support CORS (Cross-Origin Resource Sharing) headers for all public-facing APIs.&lt;/p>
&lt;p>Consider supporting a CORS allowed origin of “*”, and enforcing authorization through valid OAuth tokens.&lt;/p>
&lt;p>Avoid combining user credentials with origin validation.&lt;/p>
&lt;h2 id="20-security">20. Security&lt;/h2>
&lt;p>Enforce HTTPS (TLS-encrypted) across all endpoints, resources, and services.&lt;/p>
&lt;p>Enforce and require HTTPS for all callback URLs, push notification endpoints, and webhooks.&lt;/p>
&lt;h2 id="21-errors">21. Errors&lt;/h2>
&lt;p>Errors, or more specifically service errors, occur when a client makes an invalid or incorrect request to a service or passes invalid or incorrect data to a service, and the service rejects the request.&lt;/p>
&lt;p>Examples include invalid authentication credentials, incorrect parameters, unknown version IDs, etc.&lt;/p>
&lt;ul>
&lt;li>Do return &lt;code>4xx&lt;/code> HTTP error codes when rejecting a client request due to one or more Service Errors.&lt;/li>
&lt;li>Consider processing all attributes and then returning multiple validation problems in a single response.&lt;/li>
&lt;/ul>
&lt;h2 id="22-golden-rules">22. Golden Rules&lt;/h2>
&lt;p>If you are ever in doubt about an API formatting decision, these golden rules can help guide us to making the right decision.&lt;/p>
&lt;ul>
&lt;li>Flat is better than nested.&lt;/li>
&lt;li>Simple is better than complex.&lt;/li>
&lt;li>Strings are better than numbers.&lt;/li>
&lt;li>Consistency is better than customization.&lt;/li>
&lt;/ul></description></item><item><title>Topics: Comparing API Architectural Styles: SOAP vs REST vs GraphQL vs RPC</title><link>/topics/api-management/api-architectural-styles/soap-vs-rest-vs-graphql-vs-rpc/</link><pubDate>Fri, 29 May 2020 00:00:00 +0000</pubDate><guid>/topics/api-management/api-architectural-styles/soap-vs-rest-vs-graphql-vs-rpc/</guid><description>
&lt;blockquote>
&lt;p>&lt;a href="https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/">https://www.altexsoft.com/blog/soap-vs-rest-vs-graphql-vs-rpc/&lt;/a> | 2020-05-29&lt;/p>
&lt;/blockquote>
&lt;p>Two separate applications need an intermediary to talk to each other. So, developers often build bridges – &lt;a href="https://www.altexsoft.com/blog/engineering/what-is-api-definition-types-specifications-documentation/">Application Programming Interfaces&lt;/a> – to allow one system to access the information or functionality of another.&lt;/p>
&lt;p>In order to integrate applications quickly and at scale, APIs are realized using protocols and/or specifications to define the semantics and syntax of the messages passed across the wire. These specifications make up the API architecture.&lt;/p>
&lt;p>Over time, different API architectural styles have been released. Each of them has its own patterns of standardizing data exchange. A pull of choices raises endless debates as to which architectural style is best.&lt;/p>
&lt;p>&lt;img src="images/1.png" alt="API timeline">&lt;/p>
&lt;p>&lt;em>API styles over time, Source:&lt;/em> &lt;a href="https://twitter.com/robdcrowley?lang=en">&lt;em>Rob Crowley&lt;/em>&lt;/a>&lt;/p>
&lt;p>Today, many API consumers refer to REST as “&lt;em>REST in peace&lt;/em>” and cheer for GraphQL, while ten years ago it was a reverse story with REST as the winner to replace SOAP. The problem with these opinions is that they are one-sided picking a technology itself instead of considering how its actual properties and characteristics match the situation at hand.&lt;/p>
&lt;p>In this article, we’ll stay objective and discuss the four major API styles in the order of their appearance, compare their strong and weak sides, and highlight the scenarios where each of them fits best.&lt;/p>
&lt;p>&lt;img src="images/2.png" alt="Four major API styles compared">&lt;/p>
&lt;p>&lt;em>Four major API styles compared&lt;/em>&lt;/p>
&lt;h2 id="1-remote-procedure-call-rpc-invoking-a-function-on-another-system">1. Remote Procedure Call (RPC): invoking a function on another system&lt;/h2>
&lt;p>A &lt;strong>Remote Procedure Call&lt;/strong> is a specification that allows for remote execution of a function in a different context. RPC extends the notion of local procedure calling but puts it in the context of an HTTP API.&lt;/p>
&lt;p>Initial XML-RPC was problematic because ensuring data types of XML payloads is tough. So, later an RPC API started using a more concrete &lt;a href="https://www.jsonrpc.org/">JSON-RPC&lt;/a> specification which is considered a simpler alternative to SOAP. &lt;a href="https://grpc.io/">gRPC&lt;/a> is the latest RPC version developed by Google in 2015. With pluggable support for load balancing, tracing, health checking, and authentication, gRPC is well-suited for connecting microservices.&lt;/p>
&lt;h3 id="11-how-rpc-works">1.1 How RPC works&lt;/h3>
&lt;p>A client invokes a remote procedure, serializes the parameters and additional information into a message, and sends the message to a server. On receiving the message, the server deserializes its content, executes the requested operation, and sends a result back to the client. The server stub and client stub take care of the serialization and deserialization of the parameters.&lt;/p>
&lt;p>&lt;img src="images/3.png" alt="Remote Procedure Calling Mechanism">&lt;/p>
&lt;p>&lt;em>Remote Procedure Calling Mechanism, Source:&lt;/em> &lt;a href="https://www.guru99.com/remote-procedure-call-rpc.html#1">&lt;em>Guru99&lt;/em>&lt;/a>&lt;/p>
&lt;h3 id="12-rpc-pros">1.2 RPC Pros&lt;/h3>
&lt;p>&lt;strong>Straightforward and simple interaction.&lt;/strong> RPC uses GET to fetch information and POST for everything else. The mechanics of the interaction between a server and a client come down to calling an endpoint and getting a response.&lt;/p>
&lt;p>&lt;strong>Easy-to-add functions.&lt;/strong> If we get a new requirement for our API, we can easily add another endpoint executing this requirement: 1) Write a new function and throw it behind an endpoint and 2) now a client can hit this endpoint and get the info meeting the set requirement.&lt;/p>
&lt;p>&lt;strong>High performance.&lt;/strong> Lightweight payloads go easy on the network providing high performance, which is important for shared servers and for parallel computations executing on networks of workstations. RPC is able to optimize the network layer and make it very efficient with sending tons of messages per day between different services.&lt;/p>
&lt;h3 id="13-rpc-cons">1.3 RPC Cons&lt;/h3>
&lt;p>&lt;strong>Tight coupling to the underlying system.&lt;/strong> An API’s abstraction level contributes to its reusability. The tighter it is to the underlying system, the less reusable it will be for other systems. RPC’s tight coupling to the underlying system doesn’t allow for an abstraction layer between the functions in the system and the external API. This raises security issues as it’s quite easy to leak implementation details about the underlying system into the API. An RPC’s tight coupling makes scalability requirements and loosely coupled teams hard to achieve. So, the client either worries about any possible side effects of calling a particular endpoint or tries figuring out what endpoint to call because it doesn’t understand how the server is naming its functions.&lt;/p>
&lt;p>&lt;strong>Low discoverability.&lt;/strong> In RPC there’s no way to introspect the API or send a request and start understanding what function to call based on its requests.&lt;/p>
&lt;p>&lt;strong>Function explosion.&lt;/strong> It’s so easy to create new functions. So, instead of editing the existing ones, we create new ones ending up with a huge list of overlapping functions that are hard to understand.&lt;/p>
&lt;h3 id="14-rpc-use-cases">1.4 RPC use cases&lt;/h3>
&lt;p>The RPC pattern started being used around the 80s, but this doesn’t automatically make it obsolete. Big companies like Google, Facebook (&lt;a href="https://thrift.apache.org/">Apache Thrift&lt;/a>), and Twitch (&lt;a href="https://twitchtv.github.io/twirp/docs/intro.html">Twirp&lt;/a>) are using RPC high-performance variates internally to perform extremely high-performance, low-overhead messaging. Their massive microservices systems require internal communication to be clear while arranged in short messages.&lt;/p>
&lt;p>&lt;strong>Command API.&lt;/strong> An RPC is the proper choice for sending commands to a remote system. For instance, a Slack API is very command-focused: Join a channel, leave a channel, send a message. So, the designers of the Slack API modeled it in an RPC-like style making it small, tight, and easy to use.&lt;/p>
&lt;p>&lt;strong>Customer-specific APIs for internal microservices&lt;/strong>. Having direct integration between a single provider and consumer, we don’t want to spend a lot of time transmitting a lot of metadata over the wire, like a REST API does. With high message rate and message performance, gRPC and Twirp are strong cases for microservices. Using HTTP 2 under the hood, gRPC is able to optimize the network layer and make it very efficient with sending tons of messages per day between different services. However, if you’re not aiming at high network performance, but rather at a stable API contact between teams publishing highly distinctive microservices, REST will ensure that.&lt;/p>
&lt;h2 id="2-simple-objects-access-protocol-soap-making-data-available-as-services">2. Simple Objects Access Protocol (SOAP): making data available as services&lt;/h2>
&lt;p>&lt;a href="https://www.altexsoft.com/blog/engineering/what-is-soap-formats-protocols-message-structure-and-how-soap-is-different-from-rest/#soap-use-cases">&lt;strong>SOAP&lt;/strong>&lt;/a> is an XML-formatted, highly standardized web communication protocol. Released by Microsoft a year after XML-RPC, SOAP inherited a lot from it. When REST followed, they were first used in parallel, but soon REST won the popularity contest.&lt;/p>
&lt;h3 id="21-how-soap-works">2.1 How SOAP works&lt;/h3>
&lt;p>XML data format drags behind a lot of formality. Paired with the massive message structure, it makes SOAP the most verbose API style.&lt;/p>
&lt;p>A SOAP message is composed of:&lt;/p>
&lt;ul>
&lt;li>an envelope tag that begins and ends every message,&lt;/li>
&lt;li>a body containing the request or response&lt;/li>
&lt;li>a header if a message must determine any specifics or extra requirements, and&lt;/li>
&lt;li>a fault informing of any errors that can occur throughout the request processing.&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="images/4.png" alt="An example of the SOAP message">&lt;/p>
&lt;p>&lt;em>An example of the SOAP message. Source:&lt;/em> &lt;a href="https://www.ibm.com/support/knowledgecenter/en/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac55780_.htm">&lt;em>IBM&lt;/em>&lt;/a>&lt;/p>
&lt;p>The SOAP API logic is written in Web Service Description Language (WSDL). This API description language defines the endpoints and describes all processes that can be performed. This allows different programming languages and IDEs to quickly set up communication.&lt;/p>
&lt;p>SOAP supports both stateful and stateless messaging. In a stateful scenario, the server stores the received information that can be really heavy. But it’s justified for operations involving multiple parties and complex transactions.&lt;/p>
&lt;h3 id="22-soap-pros">2.2 SOAP Pros&lt;/h3>
&lt;p>&lt;strong>Language- and platform-agnostic.&lt;/strong> The built-in functionality to create web-based services allows SOAP to handle communications and make responses language- and platform-independent.&lt;/p>
&lt;p>&lt;strong>Bound to a variety of transport protocols.&lt;/strong> SOAP is flexible in terms of transfer protocols to accommodate for multiple scenarios.&lt;/p>
&lt;p>&lt;strong>Built-in error handling.&lt;/strong> SOAP API specification allows for returning the Retry XML message with error code and its explanation.&lt;/p>
&lt;p>&lt;strong>A number of security extensions.&lt;/strong> Integrated with the WS-Security protocols, SOAP meets an enterprise-grade transaction quality. It provides privacy and integrity inside the transactions while allowing for encryption on the message level.&lt;/p>
&lt;p>&lt;img src="images/5.png" alt="SOAP message-level security: authentication data in the header element and encrypted body">&lt;/p>
&lt;p>&lt;em>SOAP message-level security: authentication data in the header element and encrypted body&lt;/em>&lt;/p>
&lt;h3 id="23-soap-cons">2.3 SOAP Cons&lt;/h3>
&lt;p>These days, many developers shudder at the idea of having to integrate a SOAP API for several reasons.&lt;/p>
&lt;p>&lt;strong>XML only.&lt;/strong> SOAP messages contain a lot of metadata and only support verbose XML structures for requests and responses.&lt;/p>
&lt;p>&lt;strong>Heavyweight.&lt;/strong> Due to the large size of XML-files, SOAP services require a large bandwidth.&lt;/p>
&lt;p>&lt;strong>Narrowly specialized knowledge.&lt;/strong> Building SOAP API servers requires a deep understanding of all protocols involved and their highly restricted rules.&lt;/p>
&lt;p>&lt;strong>Tedious message updating.&lt;/strong> Requiring additional effort to add or remove the message properties, rigid SOAP schema slows down adoption.&lt;/p>
&lt;h3 id="24-soap-use-cases">2.4 SOAP use cases&lt;/h3>
&lt;p>Right now, the SOAP architecture is most commonly used for internal integration within enterprises or with their trusted partners.&lt;/p>
&lt;p>&lt;strong>Highly secured data transmission.&lt;/strong> SOAP rigid structure, security and authorization capabilities make it the most suitable option for enforcing a formal software contract between API and client while complying with the legal contract between the API provider and API consumer. That’s why financial organizations and other corporate users opt for SOAP.&lt;/p>
&lt;h2 id="3-representational-state-transfer-rest-making-data-available-as-resources">3. Representational state transfer (REST): making data available as resources&lt;/h2>
&lt;p>&lt;strong>REST&lt;/strong> is a self-explanatory API architectural style defined by a set of architectural constraints and intended for wide adoption with many API consumers.&lt;/p>
&lt;p>The most common API style today was originally described in 2000 by Roy Fielding in his &lt;a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">doctoral dissertation&lt;/a>. REST makes server-side data available representing it in simple formats, often JSON and XML.&lt;/p>
&lt;h3 id="31-how-rest-works">3.1 How REST works&lt;/h3>
&lt;p>REST isn’t as strictly defined as SOAP. RESTful architecture should comply with six architectural constraints:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>uniform interface:&lt;/strong> permitting a uniform way of interacting with a given server regardless of device or application type&lt;/li>
&lt;li>&lt;strong>stateless&lt;/strong>: the necessary state to handle the request as contained within the request itself and without the server storing anything related to the session&lt;/li>
&lt;li>&lt;strong>caching&lt;/strong>&lt;/li>
&lt;li>&lt;strong>client-server architecture:&lt;/strong> allowing for independent evolution of either side&lt;/li>
&lt;li>&lt;strong>layered system&lt;/strong> of the application&lt;/li>
&lt;li>the ability for servers to &lt;strong>provide executable code&lt;/strong> to the client&lt;/li>
&lt;/ul>
&lt;p>In fact, some services are RESTful only to a degree. They have RPC style at the core, break down larger services into resources, and use HTTP infrastructure efficiently. But the key part is using hypermedia aka HATEOAS, short for &lt;a href="https://en.wikipedia.org/wiki/HATEOAS">Hypertext As The Engine of Application State&lt;/a>. Basically, it means that with each response, a REST API provides metadata linking to all the related info about how to use the API. That’s what enables decoupling the client and the server. As a result, both API provider and API consumer can evolve independently without hindering their communication.&lt;/p>
&lt;p>&lt;img src="images/6.png" alt="Richardson Maturity Model as a goalpost to achieving truly complete and useful APIs">&lt;/p>
&lt;p>&lt;em>Richardson Maturity Model as a goalpost to achieving truly complete and useful APIs, Source:&lt;/em> &lt;a href="https://nordicapis.com/what-is-the-richardson-maturity-model/">&lt;em>Kristopher Sandoval&lt;/em>&lt;/a>&lt;/p>
&lt;p>&lt;em>“HATEOAS is a key feature of REST. It’s really what makes REST REST. Since most people don’t use HATEOAS, they are actually using HTTP RPC,”&lt;/em> that’s some radical opinion expressed on &lt;a href="https://www.reddit.com/r/golang/comments/7qvi0w/twirp_a_sweet_new_rpc_framework_for_go_twitch_blog/dstkrnm/">Reddit&lt;/a>. Indeed, HATEOAS is the most mature version of REST. However, it’s difficult to achieve requiring much more advanced and intelligent API clients than those typically used and built today. So, even really good REST APIs today don’t always do it. This is why HATEOAS mainly serves as a vision for the long term development of a RESTful API design.&lt;/p>
&lt;p>There really may be a gray zone between REST and RPC, when a service implements some features of REST and some of RPC. REST is based on the resource or noun instead of action or verb-based.&lt;/p>
&lt;p>&lt;img src="images/7.png" alt="Opposing operations in verb-centric RPC to the ones in noun-centric REST">&lt;/p>
&lt;p>&lt;em>Opposing operations in verb-centric RPC to the ones in noun-centric REST&lt;/em>&lt;/p>
&lt;p>In REST, things are done using HTTP methods such as GET, POST, PUT, DELETE, OPTIONS, and, hopefully, PATCH.&lt;/p>
&lt;p>&lt;img src="images/8.png" alt="REST API">&lt;/p>
&lt;p>&lt;em>Source: Thomas Davis&lt;/em>&lt;/p>
&lt;h3 id="32-rest-pros">3.2 REST Pros&lt;/h3>
&lt;p>&lt;strong>Decoupled client and server.&lt;/strong> Decoupling the client and the server as much as possible, REST allows for a better abstraction than RPC. A system with abstraction levels is able to encapsulate its details to better identify and sustain its properties. This makes a REST API flexible enough to evolve over time while remaining a stable system.&lt;/p>
&lt;p>&lt;strong>Discoverability.&lt;/strong> Communication between the client and server describes everything so that no external documentation is required to understand how to interact with the REST API.&lt;/p>
&lt;p>&lt;strong>Cache-friendly.&lt;/strong> Reusing a lot of HTTP tools, REST is the only style that allows caching data on the HTTP level. In contrast, caching implementation on any other API will require configuring an additional cache module.&lt;/p>
&lt;p>&lt;strong>Multiple formats support.&lt;/strong> The ability to support multiple formats for storing and exchanging data is one of the reasons REST is currently a prevailing choice for building public APIs.&lt;/p>
&lt;h3 id="33-rest-cons">3.3 REST Cons:&lt;/h3>
&lt;p>&lt;strong>No single REST structure.&lt;/strong> There’s no exact right way to build a REST API. How to model resources and which resources to model will depend on each scenario. This makes REST simple in theory, but difficult in practice.&lt;/p>
&lt;p>&lt;strong>Big payloads.&lt;/strong> REST returns a lot of rich metadata so that the client can understand everything necessary about the state of the application just from its responses. And this chattiness is no big deal for a big network pipe with lots of bandwidth capacity. But that’s not always the case. This was the key driving factor for Facebook coming up with the description of GraphQL style in 2012.&lt;/p>
&lt;p>&lt;strong>Over- and under-fetching problems.&lt;/strong> Containing either too much data or not enough of it, REST responses often create the need for another request.&lt;/p>
&lt;h3 id="34-rest-use-cases">3.4 REST use cases&lt;/h3>
&lt;p>&lt;strong>Management APIs.&lt;/strong> APIs focused on managing objects in a system and intended for many consumers are the most common API type. REST helps such APIs to have strong discoverability, good documentation, and it fits this object model well.&lt;/p>
&lt;p>&lt;strong>Simple resource-driven apps.&lt;/strong> REST is a valuable approach for connecting resource-driven apps that don’t need flexibility in queries.&lt;/p>
&lt;h2 id="4-graphql-querying-just-the-needed-data">4. GraphQL: querying just the needed data&lt;/h2>
&lt;p>It takes a number of calls to the REST API for it to return the needed staff. So GraphQL was invented to be a game-changer.&lt;/p>
&lt;p>&lt;a href="https://www.altexsoft.com/blog/engineering/graphql-core-features-architecture-pros-and-cons/">&lt;strong>GraphQL&lt;/strong>&lt;/a> is a syntax that describes how to make a precise data request. Implementing GraphQL is worth it for an application’s data model with a lot of complex entities referencing each other.&lt;/p>
&lt;p>&lt;img src="images/9.png" alt="How to retrieve only the needed data from the GraphQL endpoint">&lt;/p>
&lt;p>&lt;em>How to retrieve only the needed data from the GraphQL endpoint, Source:&lt;/em> &lt;a href="https://medium.com/@mohittikoo/rest-vs-graphql-will-graphql-do-to-rest-what-xml-did-to-json-c99e4fa639c3">&lt;em>Mohit Tikoo&lt;/em>&lt;/a>&lt;/p>
&lt;p>These days the GraphQL ecosystem is expanding with libraries and powerful tools like Apollo, GraphiQL, and GraphQL Explorer.&lt;/p>
&lt;h3 id="41-how-graphql-works">4.1 How GraphQL works&lt;/h3>
&lt;p>GraphQL starts with building a &lt;em>schema,&lt;/em> which is a description of all the queries you can possibly make in a GraphQL API and all the &lt;em>types&lt;/em> that they return. Schema-building is hard as it requires strong typing in the Schema Definition Language (SDL).&lt;/p>
&lt;p>Having the schema before querying, a client can validate their query against making sure the server will be able to respond to it. On reaching the backend application, a GraphQL operation is interpreted against the entire schema, and resolved with data for the frontend application. Sending one massive query to the server, the API returns a JSON response with exactly the shape of the data we asked for.&lt;/p>
&lt;p>&lt;img src="images/10.png" alt="Query execution in GraphQL">&lt;/p>
&lt;p>&lt;em>Query execution in GraphQL, Source:&lt;/em> &lt;a href="https://www.apollographql.com/blog/graphql-explained-5844742f195e">&lt;em>Jonas Helfer&lt;/em>&lt;/a>&lt;/p>
&lt;p>In addition to the RESTful CRUD operations, GraphQL has &lt;em>subscriptions&lt;/em> allowing for real-time notifications from the server.&lt;/p>
&lt;h3 id="42-graphql-pros">4.2 GraphQL Pros&lt;/h3>
&lt;p>&lt;strong>Typed schema.&lt;/strong> GraphQL publishes in advance what it can do, which improves its discoverability. By pointing a client at the GraphQL API, we can find out what queries are available.&lt;/p>
&lt;p>&lt;strong>Fits graph-like data very well.&lt;/strong> Data that goes far into linked relations but not good for flat data.&lt;/p>
&lt;p>&lt;strong>No versioning.&lt;/strong> The best practice with versioning is not to version the API at all.&lt;/p>
&lt;p>While REST offers multiple API versions, GraphQL uses a single, evolving version that gives continuous access to new features and contributes to cleaner, more maintainable server code.&lt;/p>
&lt;p>&lt;strong>Detailed error messages.&lt;/strong> In a similar fashion to SOAP, GraphQL provides details to errors that occurred. Its error message includes all the resolvers and refers to the exact query part at fault.&lt;/p>
&lt;p>&lt;strong>Flexible permissions.&lt;/strong> GraphQL allows for selectively exposing certain functions while preserving private information. Meanwhile, REST architecture doesn’t reveal data in portions. It’s either all or nothing.&lt;/p>
&lt;h3 id="43-graphql-cons">4.3 GraphQL Cons&lt;/h3>
&lt;p>&lt;strong>Performance issues.&lt;/strong> GraphQL trades off complexity for its power. Having too many nested fields in one request can lead to system overload. So, REST remains a better option for complex queries.&lt;/p>
&lt;p>&lt;strong>Caching complexity.&lt;/strong> As GraphQL isn’t reusing HTTP caching semantics, it requires a custom caching effort.&lt;/p>
&lt;p>&lt;strong>A lot of pre-development education.&lt;/strong> Not having enough time to figure out GraphQL niche operations and SDL, many projects decide to follow the well-known path of REST.&lt;/p>
&lt;h3 id="44-graphql-use-cases">4.4 GraphQL use cases&lt;/h3>
&lt;p>&lt;strong>Mobile API.&lt;/strong> In this case, network performance and single message payload optimization is important. So, GraphQL offers a more efficient data loading for mobile devices.&lt;/p>
&lt;p>&lt;strong>Complex systems and microservices.&lt;/strong> GraphQL is able to hide the complexity of multiple systems integration behind its API. Aggregating data from multiple places, it merges them into one global schema. This is particularly relevant for &lt;a href="https://www.altexsoft.com/whitepapers/legacy-system-modernization-how-to-transform-the-enterprise-for-digital-future/">legacy infrastructures&lt;/a> or third-party APIs that have expanded over time.&lt;/p>
&lt;h2 id="5-which-api-pattern-fits-your-use-case-best">5. Which API pattern fits your use case best?&lt;/h2>
&lt;p>Every API project has different requirements and needs. Usually, the architectural choice depends on&lt;/p>
&lt;ul>
&lt;li>the programming language in use,&lt;/li>
&lt;li>the environment in which you’re developing, and&lt;/li>
&lt;li>the resources you have to spare, both human and financial.&lt;/li>
&lt;/ul>
&lt;p>Knowing all the tradeoffs that go into each design style, API designers can pick the one that’s going to fit the project best.&lt;/p>
&lt;p>With its tight coupling, RPC works for internal microservices but it’s not an option for a strong external API or an API service.&lt;/p>
&lt;p>SOAP is troublesome but its rich security features remain irreplaceable for billing operations, booking systems, and payments.&lt;/p>
&lt;p>REST has the highest abstraction and best modeling of the API. But it tends to be heavier on the wire and chattier – a downside if you’re working on mobile.&lt;/p>
&lt;p>GraphQL is a big step forward in terms of data fetching but not everyone has enough time and effort to get the hang of it.&lt;/p>
&lt;p>At the end of the day, it makes sense to try a few small use cases with a particular style, and see if it fits your use case and solves your problems. If it does, try expanding and see if it fits more use cases.&lt;/p></description></item><item><title>Topics: Introduction to API Versioning Best Practices</title><link>/topics/api-management/api-versioning/introduction-to-api-versioning-best-practices/</link><pubDate>Fri, 03 Nov 2017 00:00:00 +0000</pubDate><guid>/topics/api-management/api-versioning/introduction-to-api-versioning-best-practices/</guid><description>
&lt;blockquote>
&lt;p>&lt;a href="https://nordicapis.com/introduction-to-api-versioning-best-practices/">https://nordicapis.com/introduction-to-api-versioning-best-practices/&lt;/a> | 2017-11-03&lt;/p>
&lt;/blockquote>
&lt;p>Change is inevitable and growth is a good thing. When your API has reached the point of expanding beyond it’s original intent and capacity, it’s time to consider the next &lt;strong>version&lt;/strong>.&lt;/p>
&lt;p>Whether that next iteration is a whole number version bump or just a feature expansion, it’s important to consider the pros and cons of how you let your developers know about it. Far different than traditional software versioning, &lt;strong>API versioning&lt;/strong> can have complex implications for the products using it downstream.&lt;/p>
&lt;p>The big version bumps usually indicate a significant &lt;strong>milestone&lt;/strong> in the codebase of the API. It declares a &lt;strong>significant change&lt;/strong> in the requirements of API consumption and implementation. Feature additions that don’t necessarily change existing calls is part of the organic growth of a product and aren’t subject to the same considerations.&lt;/p>
&lt;p>Once you start taking things away, or dramatically changing what’s in place, it’s time to consider another version. Often, these new versions become whole new products. Although they share a common ancestry, new versions of legacy APIs require careful thought into their implementation.&lt;/p>
&lt;blockquote>
&lt;p>For more advanced API versioning insights, read &lt;a href="https://nordicapis.com/api-change-strategy/">API Change Strategy&lt;/a> or &lt;a href="https://nordicapis.com/whats-the-difference-between-versioning-and-revisioning-apis/">What’s The Difference Between Versioning and Revisioning APIs?&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="traditional-api-versioning-n1">Traditional API Versioning: n+1&lt;/h2>
&lt;p>Service changes that can warrant a new version include: removing an operation, renaming an operation, operation parameter changes that shift data types or order, and complex structural changes of data type.&lt;/p>
&lt;p>A version increment can also indicate significant changes to API consumption requirements. It can also advertise a radical change in the underlying resources offered by the API. In either case, products and platforms that rely on an API for core functionality may need a &lt;strong>code refactor&lt;/strong> to adapt.&lt;/p>
&lt;p>That can be time and resource intensive, so a sane and &lt;strong>well documented&lt;/strong> approach to URI versioning is crucial for multiple stakeholders. Versioning can be a controversial topic within teams, and often the first question is whether to even use it.&lt;/p>
&lt;h2 id="one-uri-to-rule-them-all">One URI to Rule Them All&lt;/h2>
&lt;p>One school of thought is to focus on &lt;strong>one unchanging URI&lt;/strong> with just one set of criteria for consumption. If the API structure is changed, resources altered, or parameter set modified, then the product is re-launched with the same URI. This pushes the obligation to refactor code to downstream developers.&lt;/p>
&lt;p>Tim Berners-Lee gets name dropped by proponents of this approach. He is often &lt;a href="https://www.technologyreview.com/s/403095/sir-tim-berners-lee/">quoted as saying&lt;/a> “a cool URI is one which does not change.” In context, that quote was intended to address the nascent internet which depended on hyperlinks within web pages to endure. The &lt;a href="http://nordicapis.com/what-is-json-ld/">connected web&lt;/a>, at that time, was a series of information nodes.&lt;/p>
&lt;p>The world has changed, though, and we work with a interconnected matrix of powerful and resource heavy web services. Once services became widespread, early approaches were similar to software version numbers. But, standalone software has very different downstream implications than interdependent web services.&lt;/p>
&lt;p>IBM addresses this in their own “&lt;a href="https://www.ibm.com/developerworks/webservices/library/ws-version/">Best practices for Web services&lt;/a>“:&lt;/p>
&lt;blockquote>
&lt;p>“The correct handling of API versioning has been one of the most difficult issues faced by developers of distributed systems. Various schemes have been proposed, ranging from the laissez faire approach taken by CORBA (Common Object Request Broker Architecture) to the stricter schemes used in DCOM (Distributed Component Object Model). With the advent of Web services, there are some new features that you can take advantage of that can help alleviate the problem, but the brutal fact of the matter is that versioning has not been built into the Web services architecture.”&lt;/p>
&lt;/blockquote>
&lt;p>What constitutes “best practices” has evolved over time and is determined by provider choices for their own products, not necessarily from any outside governing body. So, when it comes to choosing an approach to versioning, there are a wide variety of practices.&lt;/p>
&lt;h2 id="on-backwards-compatibility">On Backwards Compatibility&lt;/h2>
&lt;p>Another consideration is &lt;strong>backwards compatibility&lt;/strong>. For many providers of web resource APIs, this is the primary consideration. Maintaining multiple versions of a resource intensive API can be a serious drain on the time and focus of engineering teams. It can also introduce long term stability problems to services that have moved on to more modern architectures.&lt;/p>
&lt;p>For many, introducing a new version that substantially changes an API is, in fact, launching a &lt;strong>whole new service.&lt;/strong> Treating it as a &lt;strong>new product&lt;/strong>, with &lt;strong>new documentation&lt;/strong>, Service Level Agreements, tier access changes, etc., can have major business implications. Many a whiteboard has been filled with figures debating whether a change is an engineering choice or a &lt;em>business shift&lt;/em>.&lt;/p>
&lt;p>Once the decision has been made to introduce a new version, it’s helpful to look around at established providers for battle tested solutions.&lt;/p>
&lt;blockquote>
&lt;p>Related: &lt;a href="https://nordicapis.com/api-lifecycle-retirement-stage-a-history-of-major-public-api-retirements/">The 5 Main Business Reasons for API Retirement&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="examples-of-versioning-in-the-wild">Examples of Versioning in the Wild&lt;/h2>
&lt;p>What can we learn from the versioning practices of established web API providers? &lt;a href="https://cloud.google.com/apis/design/versioning">Google&lt;/a> comes out of the gate with a blunt affirmation of numbered versioning: “Networked APIs should use &lt;strong>Semantic Versioning&lt;/strong>.” Not much wiggle room there. They also have a similarly plain system. Version indicators use the form &lt;strong>v.MAJOR.MINOR.PATCH&lt;/strong>.&lt;/p>
&lt;p>&lt;a href="https://www.twilio.com/docs/api/rest">Twilio&lt;/a> uses a &lt;strong>timestamp&lt;/strong> in the URL, instead of a version number. &lt;a href="https://developer.salesforce.com/blogs/developer-relations/2013/10/api-versions-and-the-salesforce-metadata-api.html">Salesforce&lt;/a> opts for vXX.X in the &lt;strong>middle&lt;/strong> of the URL. &lt;a href="https://developers.facebook.com/docs/apps/versions">Facebook&lt;/a> goes for prepending the version to the endpoint path. The version is actually optional, with unspecified version requests being routed to the oldest version available.&lt;/p>
&lt;p>Note that the granularity offered by vX.X is usually intended for development and not necessarily for production. Check the docs first, but it’s a good idea to opt for ordinal number references in production code.&lt;/p>
&lt;p>&lt;a href="http://nordicapis.com/avoid-walking-on-eggshells-and-use-devops/">DevOps&lt;/a> folks may be familiar with the &lt;strong>UDDI&lt;/strong> and &lt;strong>WDSL&lt;/strong> approach to version definitions. HTTP solutions are much more popular, but there is support for this kind of approach. It entails a version request through an &lt;strong>XML&lt;/strong> exchange to get the proper version.&lt;/p>
&lt;p>Megalithic companies like Microsoft, IBM, and Oracle have references to this method in some of their documentation. Although, HTTP version indications are accepted in many divisions and products.&lt;/p>
&lt;p>Dating network &lt;strong>Badoo&lt;/strong> opts for &lt;a href="https://nordicapis.com/continuous-versioning-strategy-for-internal-apis/">continuous versioning&lt;/a>, where features are added and endpoints stay the same. Legacy clients can use old fields and new clients use added fields. API requests are transactional, with a feature request call made and a list of available options returned. Feature checks can serve as a sort of state request.&lt;/p>
&lt;p>The &lt;a href="http://apistylebook.com/design/topics/versioning">API stylebook&lt;/a> has a few more paths to explore on versioning. Without a codified set of specifications, companies continue to explore different options.&lt;/p>
&lt;h2 id="version-with-accept-header">Version With Accept Header&lt;/h2>
&lt;p>A common alternative to path parameters is &lt;strong>header exchanges&lt;/strong>. They can be more verbose about the expected response and are usually included anyway for an HTTP request. Having a resource specific header approach allows for other parameters (such as caching, compression, and &lt;a href="http://nordicapis.com/content-negotiation/">content negotiation&lt;/a>) to be included.&lt;/p>
&lt;p>API providers often communicate &lt;strong>resource criteria&lt;/strong> and limitations in their response, so developers will need to examine the header exchange anyway. Besides just response codes, common header responses include &lt;a href="http://nordicapis.com/stemming-the-flood-how-to-rate-limit-an-api/">rate limit bounds&lt;/a>, &lt;a href="http://nordicapis.com/best-practices-api-error-handling/">specific error messages&lt;/a>, time-based data, and more.&lt;/p>
&lt;p>A clever outlier is using &lt;strong>MIME&lt;/strong> types to include a version indicator. API providers register these MIME types on their backend and then users include &lt;strong>Accept&lt;/strong> and &lt;strong>Content-type headers&lt;/strong>. IETF legitimized this approach in &lt;a href="http://www.ietf.org/rfc/rfc4627.txt">RFC4627&lt;/a>. While this does work, developers choosing this approach will inevitably end up explaining their choice to management types who state, “but it doesn’t work on HTML forms, so why do you want to do it that way?”&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#a40000">Accept: application/pre.company.app-v1+json
&lt;/span>&lt;span style="color:#a40000">Content-Type: application/pre.company.app-v1+json
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The debate over implementation is deep and will continue. So, developers and providers will have to make choices based on their specific needs. In general, the most common approach is a combination of &lt;strong>URI parameters&lt;/strong> and &lt;strong>header criteria&lt;/strong>. APIs accept URI requests with parameters and then return a payload with proper response codes and (hopefully) verbose &lt;strong>metadata&lt;/strong> in the header of the response.&lt;/p>
&lt;p>What constitutes a proper response code is something engineers will debate gleefully and loudly at company happy hours. But, here are some useful negative responses that are verbose enough to be helpful downstream.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-http" data-lang="http">&lt;span style="color:#a40000">400: BAD_REQUEST: ApiVersionUnspecified: An API version is required, but was not specified
&lt;/span>&lt;span style="color:#a40000">400: BAD_REQUEST: InvalidApiVersion: An API version was specified, but it is invalid
&lt;/span>&lt;span style="color:#a40000">400: BAD_REQUEST: AmbiguousApiVersion: An API version was specified multiple times with different values
&lt;/span>&lt;span style="color:#a40000">400, 405: BAD_REQUEST, METHOD_NOT_ALLOWED: UnsupportedApiVersion: The specified API version is not supported
&lt;/span>&lt;span style="color:#a40000">301: MOVED_PERMANENTLY: movedPermanently: This request and future requests for the same operation have
&lt;/span>&lt;span style="color:#a40000">to be sent to the URL specified in the Location header of this response
&lt;/span>&lt;span style="color:#a40000">instead of to the URL to which this request was sent
&lt;/span>&lt;span style="color:#a40000">410: GONE: deleted: The request failed because the resource associated with the request has been deleted
&lt;/span>&lt;span style="color:#a40000">299: OK: Warning: &amp;#34;Deprecated API&amp;#34;
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For More on Error Responses read: &lt;a href="https://nordicapis.com/best-practices-api-error-handling/">Best Practices for API Error Handling&lt;/a>&lt;/p>
&lt;h2 id="business-motives-will-direct-versioning-choices">Business Motives Will Direct Versioning Choices&lt;/h2>
&lt;p>In some ways, the technical aspects of versioning are the easiest to work out. The real debate comes down to product needs, &lt;strong>business concerns&lt;/strong>, and future plans. The requirements for supporting multiple versions of an API can be very high in terms of engineering support, backend resources, and simple bandwidth.&lt;/p>
&lt;p>Also, to be done well, a new version needs &lt;strong>rich documentation&lt;/strong> to successfully transition. Since up-to-date documentation is often low on the priorities of fast moving companies, it can end up getting launched poorly as a mashup of old documentation and new. Bad documentation can yield deep costs in time and money.&lt;/p>
&lt;p>The main takeaway here is that versioning is a &lt;strong>multi-faceted&lt;/strong> conversation. It’s not just a technical problem. The downstream effects and legacy costs can be substantial and the entire process should be well thought out for effective growth.&lt;/p></description></item></channel></rss>