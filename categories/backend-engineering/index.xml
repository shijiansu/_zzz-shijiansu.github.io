<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shijian Homepage – Backend Engineering</title><link>/categories/backend-engineering/</link><description>Recent content in Backend Engineering on Shijian Homepage</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 25 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/backend-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>Topics: Introduction to Open Application Model</title><link>/topics/cloud-native/open-application-model/introduction-to-open-application-model/</link><pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate><guid>/topics/cloud-native/open-application-model/introduction-to-open-application-model/</guid><description>
&lt;p>An open standard for defining cloud native apps.&lt;/p>
&lt;p>Focused on application rather than container or orchestrator, Open Application Model [OAM] brings modular, extensible, and portable design for modeling application deployment with higher level yet consistent API.&lt;/p>
&lt;p>This is the key to enable simple yet robust application delivery across hybrid environments including Kubernetes, cloud, or even IoT devices.&lt;/p>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;h3 id="1-traditional-way---app-deployment-is-hard">1. Traditional Way - App Deployment is Hard&lt;/h3>
&lt;ol>
&lt;li>Developers spend time on infrastructure details instead of apps - ingress, labels, DNS, etc, and learning how the infrastructure is implemented.&lt;/li>
&lt;li>Inextensible - upper layer platform may be introduced, but it&amp;rsquo;s almost certain that the needs of your app will outgrow the capabilities of that platform soon.&lt;/li>
&lt;li>Runtime lock-in - app description is tightly coupled with the runtime infrastructure, which heavily impact on how you configure, develop and operate the app across hybrid environments.&lt;/li>
&lt;/ol>
&lt;h3 id="2-the-oam-way---an-app-centric-approach">2. The OAM Way - An App-centric Approach&lt;/h3>
&lt;ol>
&lt;li>Application first - define the app with a self-contained model, where operational behaviors as part of app definition, free of infrastructure here.&lt;/li>
&lt;li>Clarity and extensibility - an open standard to modularize platform capabilities into reusable pieces, assemble them into an app deployment per your own needs, fully self-service.&lt;/li>
&lt;li>Runtime agnostic - a consistent experience to deploy and operate your apps across on-prem clusters, cloud providers or even edge devices.&lt;/li>
&lt;/ol>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;blockquote>
&lt;p>&amp;ldquo;Developers think in terms of application architecture, not of infrastructure.&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="images/introduction.png" alt="">&lt;/p>
&lt;h2 id="overview-of-the-model">Overview of the Model&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/oam-dev/spec/blob/master/2.overview_and_terminology.md">https://github.com/oam-dev/spec/blob/master/2.overview_and_terminology.md&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>This specification proposes a model that defines cloud native applications as follows:&lt;/p>
&lt;blockquote>
&lt;p>A cloud native application is a collection of interrelated, but discrete components (services, tasks, workers) that, when coupled with configuration and instantiated in a suitable runtime, together accomplish a unified functional purpose.&lt;/p>
&lt;/blockquote>
&lt;p>In current release, this application model defines the following:&lt;/p>
&lt;ul>
&lt;li>Components represents a runnable unit, together with a description (schematic).&lt;/li>
&lt;li>Workload types identify the different workloads that a component can execute.&lt;/li>
&lt;li>Traits are overlays that augment a component with additional operations-specific features. Traits represent operator concerns, not developer/software owner concerns.&lt;/li>
&lt;li>Application scopes represent application boundaries by grouping components with common properties or dependencies.&lt;/li>
&lt;li>An application configuration assembles a set of component instances, their traits, and the application scopes in which they are placed, combined with configuration parameters and metadata.&lt;/li>
&lt;/ul>
&lt;p>Thus, an application is a collection of components with a set of operational traits and scoped together into one or more application boundaries.&lt;/p>
&lt;h2 id="see-it-in-action">See it in action&lt;/h2>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/oam-dev/kubevela">https://github.com/oam-dev/kubevela&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Topics: Internal Platform Teams - What Are They and Do You Need One</title><link>/topics/platform-engineering/internal-developer-platform-idp/internal-platform-teams-what-are-they-and-do-you-need-one/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><guid>/topics/platform-engineering/internal-developer-platform-idp/internal-platform-teams-what-are-they-and-do-you-need-one/</guid><description>
&lt;p>The early 2000s, the era of the SysAdmin. They were the ultimate rulers of the infrastructure, the gatekeepers of any setup. If your app developers wanted anything done, they needed to pass through them. Specifically, this meant every script and piece of code was thrown over the fence to SysAdmins to figure out what to do with it and how to deploy it. Not a great experience on either side of the fence. Then 2007 came and Werner Vogels &lt;a href="https://queue.acm.org/detail.cfm?id=1142065">famously yelled&lt;/a>: “You build it, you run it”. And a whole generation of SysAdmins was fired. Cloud native was finally allowing developers to provision the resources they needed, whenever they needed them. The answer to every dev teams’ problems. Or was it?&lt;/p>
&lt;p>While it did bring about a plethora of improvements around scalability, availability and ease of operation, it turns out Cloud native also meant things got a lot more complicated. As every company’s value proposition becomes digitized (&lt;a href="https://www.youtube.com/watch?v=ZAKn9qkYEwU&amp;amp;t=1978s">as Twilio’s CEO explains&lt;/a>), the degree of complexity of its systems grows exponentially. They suddenly need to integrate with countless new technologies, be deployed across multiple clusters and vendors in different regions, all while offering an effortless end experience to customers. The result of all of this is that your frontend app developers are completely overwhelmed by the sheer amount of tools that make up your infrastructure. And whenever they are supposed to be using those YAML files for their deployments, they end up going to your Ops team to ask for help. So much for “you build it, you run it”.&lt;/p>
&lt;h2 id="the-key-to-true-devops">The key to true DevOps&lt;/h2>
&lt;p>Once they realized this approach to DevOps just wasn’t going to scale the way they needed it to, top-tier engineering organizations started looking at alternative solutions. In order to grow rapidly, while keeping their systems reliable and maintainable, and without compromising their developers' end experience of working with the infrastructure, leading tech organizations introduced Internal Platform teams.&lt;/p>
&lt;p>Platform teams build internal workflows and tooling, such as &lt;a href="https://humanitec.com/blog/what-is-an-internal-developer-platform">Internal Developer Platforms (IDPs)&lt;/a>, to ensure application developers are shielded from the evolving complexities of the underlying infrastructure. They create a smooth development and deployment experience for everyone involved.&lt;/p>
&lt;p>The common thread in everything they do: enable developer self-service across the organization. As Skelton and Pais explain in &lt;a href="https://teamtopologies.com/book">Team Topologies&lt;/a>,&lt;/p>
&lt;p>“The Platform team’s knowledge is best made available via self-service capabilities via a web portal and or/programmable API [i.e. an IDP] (as opposed to lengthy instruction manuals)”.&lt;/p>
&lt;p>&lt;a href="https://puppet.com/resources/report/2020-state-of-devops-report/">The 2020 State of DevOps report by Puppet&lt;/a> clearly surfaces this by mapping the level of DevOps sophistication against the use of self-service platforms built by Platform teams.&lt;/p>
&lt;p>&lt;img src="images/1.png" alt="1">&lt;/p>
&lt;p>Source: &lt;a href="https://puppet.com/resources/report/2020-state-of-devops-report/">2020 State of DevOps report by Puppet&lt;/a>&lt;/p>
&lt;p>Jason Warner, CTO at GitHub, &lt;a href="https://humanitec.com/blog/jason-warner-why-github-built-their-own-internal-developer-platform">explained in his interview with us&lt;/a> how building their platform team and their IDP wasn’t really a cosmetic choice but rather a vital move on their part, which allowed GitHub to scale the way they did. Jan Löffler, Head of Platform at Zalando (largest e-commerce in Germany), &lt;a href="https://humanitec.com/blog/why-zalando-builds-an-own-developer-platform">agrees that an Internal Platform team&lt;/a>, in combination with an Internal Developer Platform, is an essential component of what makes such a large organization function and ship software so much faster than a regular team.&lt;/p>
&lt;h2 id="impressive-impact">Impressive impact&lt;/h2>
&lt;p>The strategic focus on Platform teams and developer self-service in these elite organizations clearly pays off. The results of well-trimmed Internal Platform teams are quite astounding: top performers deploy a stunning 208 times more frequently than low performers. &lt;a href="https://services.google.com/fh/files/misc/state-of-devops-2019.pdf">The 2019 Accelerate State of DevOps Report&lt;/a> shows very interesting data on the top percentile teams:&lt;/p>
&lt;p>&lt;img src="images/2.png" alt="02">&lt;/p>
&lt;p>Source: &lt;a href="https://services.google.com/fh/files/misc/state-of-devops-2019.pdf">2019 Accelerate State of DevOps Report&lt;/a>&lt;/p>
&lt;p>While these “elite performers” only make up for a fraction of the market, this trend is catching the attention of many others. According to the &lt;a href="https://www.gartner.com/en/documents/3906678/how-to-scale-devops-by-building-platform-teams">2019 Gartner DevOps report&lt;/a>, IDPs and Platform teams are increasingly the go-to approach to solve problems holistically and handle multiple teams and applications, instead of just the projects at hand. According to this report, 60% of surveyed teams are currently embarking onto the platform journey.&lt;/p>
&lt;p>We have already written at length about &lt;a href="https://humanitec.com/blog/the-rise-of-internal-developer-platforms">the rise of Internal Developer Platforms&lt;/a> in the industry and &lt;a href="https://humanitec.com/blog/what-is-an-internal-developer-platform">what they are&lt;/a>. A match made in DevOps heaven, IDPs are the indispensable companion of any Platform team. Together, they provide app developers with the best tools and workflows to do their job as efficiently and effortlessly as possible.&lt;/p>
&lt;p>&lt;strong>In this article&lt;/strong>, we will dive deeper into the Platform team side of things: the different aspects of building and scaling one, while ensuring that it continuously generates value for all your app dev teams.&lt;/p>
&lt;h2 id="how-to-build-an-internal-platform-team">How to build an Internal Platform team&lt;/h2>
&lt;p>Alright, Internal Platform teams are pretty damn important when your organization is scaling up. And if that’s you, right now you might be thinking to yourself you need one. So where do you start?&lt;/p>
&lt;h3 id="the-mission">The mission&lt;/h3>
&lt;p>As usual, from the why. When building an Internal Platform team, it is key you clearly define its purpose and mission. “To build the tools (IDPs) that enable developers to shio scalable applications with high speed, quality and performance” is an example. Whatever makes the most sense for your organization, make sure you set this in stone. Along with the mission statement, it is important you establish early on that the Platform team is not to be seen as some sort of extension of the SRE or Ops teams, but rather as its own product team, serving customers (app developers) within your organization.&lt;/p>
&lt;p>This differentiation is crucial not only from an engineering and product point of view, but also from a management perspective. In order to get buy-in on different levels, Platform teams cannot afford to be speaking only the technical language, but need to master the business lingo too. It is critical for the long term success of any Internal Platform team that it gets seen within the organization as not yet another cost center we are adding to our already expensive engineering balance sheet. Instead, it is a value center for all other app development teams and, eventually, for the end consumer.&lt;/p>
&lt;h3 id="internal-balance">Internal balance&lt;/h3>
&lt;p>Once that is cleared up, you need to strike the right balance. Successful Internal Platform teams manage to put in place strong guardrails and standards for their development teams, but without taking away too much of their autonomy. To have meaningful impact, Platform teams depend on having standards in their organization. Trying to support every possible programming language, framework, DB, and whatever exotic tech engineers like that month only results in Platform teams spreading themselves too thin. On the flip side, you don’t want to come across as a patronizing ruler of infrastructure by imposing your standards on every other team. &lt;a href="https://humanitec.com/blog/devops-standards-vs-freedom">Standards vs. freedom&lt;/a> is a complex topic we have covered before. There’s no one-size-fits-all solution here, but you have to be mindful of the challenges of introducing a centralized set of standards in your organization.&lt;/p>
&lt;p>Finally, ensure you select the right SREs and DevOps engineers to build out your team. This sounds obvious, but there’s quite some &lt;a href="https://www.reddit.com/r/sre/comments/m12sdl/becoming_a_platform_engineer/">debate around what makes for a good Platform engineer&lt;/a>. It is paramount he or she fully appreciates internal tooling as a real product to iterate on, based on the feedback of their end customer: the rest of the engineering teams. Deep technical capabilities like language skills are key for a Platform engineer, but make sure you don’t only consider technical sophistication when hiring for this position, also look for candidates with a multidisciplinary understanding of their role within the organization. Alongside these core Ops competencies, you’ll also need front-end and design roles to build a complete Platform team. Remember, they are building a full fledged product for your organization.&lt;/p>
&lt;h3 id="the-values-of-platform-teams">The value(s) of Platform teams&lt;/h3>
&lt;p>Congratulations, you convinced management to give you the green light and went off to build a world class Internal Platform team. So how do you make sure it was all worth it? At the end of the day, they are not shipping anything that’s customer facing, so how do you know they are working on the right things to maximize value for the rest of the engineering org?&lt;/p>
&lt;p>We compiled the key areas that we have seen Internal Platform teams focus on, in order to deliver the right internal tooling, standards and workflows to their application developers. The cornerstone is always the reduction of complexity and cognitive load for the end user of the Internal Developer Platform. If that is unstable, your engineering productivity will drop dramatically. But let’s get into the details.&lt;/p>
&lt;h3 id="treat-your-platform-as-a-product">Treat your platform as a product&lt;/h3>
&lt;p>We mentioned this already, but it is probably the most important takeaway: your Internal Platform team needs to be driven by a &lt;a href="https://martinfowler.com/articles/talk-about-platforms.html">product mindset&lt;/a>. They need to focus on what provides real value (as opposed to what is “cool” to work on) for their internal customers, the app developers, based on the feedback they gave them. This philosophy needs to be drilled into every aspect of your Platform team’s activities. Iterate on your Internal Developer Platform, ship new features. At the same time, don’t forget you are also responsible for maintaining a reliable and scalable Ops setup. If something goes wrong in your team, all other teams will suffer from it.&lt;/p>
&lt;p>&lt;img src="images/3.png" alt="3">&lt;/p>
&lt;p>Source: &lt;a href="https://puppet.com/resources/report/2020-state-of-devops-report/">2020 State of DevOps report by Puppet&lt;/a>&lt;/p>
&lt;h3 id="optimize-iteration-speed">Optimize iteration speed&lt;/h3>
&lt;p>When you think about it, the speed at which your organization innovates is directly correlated to (and constrained by) your iteration speed. Increase that, and your app developers will be able to consistently ship more features and products to your customers, confident that things won’t break.&lt;/p>
&lt;p>In order to do so, Internal Platform teams need to focus on optimizing every step of the software delivery process. In particular, they should:&lt;/p>
&lt;ul>
&lt;li>Make local development and testing as fast and painless as possible&lt;/li>
&lt;li>Critically simplify the way developers interact with their infrastructure (and remove the &lt;a href="https://humanitec.com/blog/tame-your-zoo-of-scripts">zoo of scripts&lt;/a> from their day to day)&lt;/li>
&lt;li>Lower barrier to entry by building the right tools and documentation that enable engineers to onboard faster. You should move away from tribal knowledge as much as you can.&lt;/li>
&lt;/ul>
&lt;h3 id="solve-common-problems">Solve common problems&lt;/h3>
&lt;p>A good Platform team prevents other teams from reinventing the wheel by solving common problems time and again. It’s key to figure out what these common problems are: start by understanding developer pain points and friction areas that cause slowdowns in development. You can gather this information both qualitatively through developers’ feedback and quantitatively via engineering KPIs. This intel, combined with an understanding of the future direction of the product, can help the Internal Platform team shape a good roadmap and pick the right battles to fight. The Puppet report gives us some insights on what the core responsibilities of Platform teams are.&lt;/p>
&lt;p>&lt;img src="images/4.png" alt="4">&lt;/p>
&lt;p>Source: &lt;a href="https://puppet.com/resources/report/2020-state-of-devops-report/">2020 State of DevOps report by Puppet&lt;/a>&lt;/p>
&lt;h3 id="be-glue-my-friend">Be glue, my friend&lt;/h3>
&lt;p>Platform teams need to define a golden path for their developers: a reduced set of sane, proven choices of tools that get the job done and allow you to build, deploy, and operate your services. Once you have defined this path, the main value you create as an Internal Platform team is to be the sticky glue that brings all the tools together and ensures a smooth development and deployment experience for your engineers.&lt;/p>
&lt;p>It’s important you don’t go to war with commercial vendors. It doesn’t matter if your homegrown CI/CD solution is superior today. AWS, GCP, Humanitec will catch up, faster than expected, and make that tool and team redundant. Every Platform team should be asking themselves: what is our differentiator? Instead of building in-house alternatives to a CI system, a CD tool or a metrics platform and compete against businesses that have 20 or 50 times your capacity, focus on the specific needs of your teams and tailor off-the-shelf solutions to your requirements. Commercial competitors are more likely to optimize for more generic needs of the industry anyway.&lt;/p>
&lt;p>&lt;img src="images/5.png" alt="5">&lt;/p>
&lt;h3 id="educate-and-empower-your-teams">Educate and empower your teams&lt;/h3>
&lt;p>Finally, a good Platform team is a central source of education and best practices for the rest of the company. Some of the most impactful activities we saw elite teams routinely perform in this area include:&lt;/p>
&lt;ul>
&lt;li>Fostering regular architectural design reviews for new functional projects and proposing common ways of development across dev teams.&lt;/li>
&lt;li>Sharing knowledge, experiences and collectively define best practices and architectural guidelines.&lt;/li>
&lt;li>Ensuring engineers have the right tools in place to validate and check for common pitfalls like code smells, bugs and performance degradations.&lt;/li>
&lt;li>Organizing internal hackathons so dev teams can surface their requirements for internal tooling needs. Nigel Simons (Director Enterprise Tech at a Fortune 100) explained in a &lt;a href="https://humanitec.com/blog/developer-experience-roundtable-continuous-improvement-nigel-simpson-erik-muttersbach">conversation with us&lt;/a> that 50% of their teams’ hackathon ideas actually make it to production.&lt;/li>
&lt;/ul>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>If you and your team are scaling up your infrastructure and adding engineers at an increasing pace, you are likely considering (or hopefully will consider, after reading this) to build an Internal Platform team. The benefits can be many and if done right, a Platform team can allow your organization to scale considerably faster and more efficiently than with a less standardized approach and product driven mentality.&lt;/p></description></item><item><title>Topics: Backend as a Service - What is a BaaS</title><link>/topics/backend-as-a-service-baas/backend-as-a-service-what-is-a-baas/</link><pubDate>Tue, 09 Feb 2021 00:00:00 +0000</pubDate><guid>/topics/backend-as-a-service-baas/backend-as-a-service-what-is-a-baas/</guid><description>
&lt;h2 id="what-is-a-backend-as-a-service">What is a backend as a service?&lt;/h2>
&lt;p>&lt;img src="images/0.png" alt="0">&lt;/p>
&lt;p>A BaaS or mBaaS or Backend as a Service is a platform that automates backend side development and takes care of the cloud infrastructure. Using a BaaS, you will outsource the responsibilities of running and maintaining servers to a third party and focus on the frontend or client-side development.&lt;/p>
&lt;p>On top of that, a BaaS will provide tools to help you create a backend code and speed up the development process. It has ready to use features like scalable databases, APIs, cloud code functions, social media integrations, file storage, and push notifications.&lt;/p>
&lt;h3 id="frontend-vs-backend">Frontend vs. Backend&lt;/h3>
&lt;p>&lt;img src="images/1.png" alt="1">&lt;/p>
&lt;p>First things, first! Here is a simple explanation of the differences between the frontend and backend.&lt;/p>
&lt;ul>
&lt;li>Frontend: Every software application has a section that the user sees that is called the frontend.&lt;/li>
&lt;li>Backend: There is also a part that the user does not see that is named backend. These two portions combine through APIs.&lt;/li>
&lt;/ul>
&lt;p>Please refer to Wikipedia know more about Frontend vs. Backend.&lt;/p>
&lt;h3 id="baas-vs-custom-backend">BaaS vs. Custom Backend&lt;/h3>
&lt;p>For every app you build, there is a choice to develop it, creating a custom backend, or using a BaaS framework. Let’s understand the difference between these two approaches.&lt;/p>
&lt;p>Going for a custom backend, you will have to create your backend from scratch and handle the infrastructure. The pros of this approach are the flexibility it provides and customization possibilities. The downsides will be higher development costs and a longer time to market.&lt;/p>
&lt;p>On the other hand, a BaaS will deliver ready to use building blocks and code generation tools. The advantages of this approach are a much faster development process and reduced time to market. The cons will be lower flexibility and following a standardized architecture.&lt;/p>
&lt;p>The following examples will help you to understand the differences between custom coding and using a BaaS.&lt;/p>
&lt;h4 id="example-01--baas-vs-aws-ec2-instances">Example 01 – BaaS vs. AWS EC2 Instances&lt;/h4>
&lt;p>Imagine you would like to build a new software project and that you will not use a BaaS. The first step before you start developing the backend side code is to set up the servers. Here is how it will work:&lt;/p>
&lt;ul>
&lt;li>Login on AWS or any other cloud.&lt;/li>
&lt;li>Go to Instances&lt;/li>
&lt;li>Launch Instance&lt;/li>
&lt;li>Select the Operating System&lt;/li>
&lt;li>Instance Size, Type&lt;/li>
&lt;li>Configure Instance Details
&lt;ul>
&lt;li>Number of instances&lt;/li>
&lt;li>Network&lt;/li>
&lt;li>IP&lt;/li>
&lt;li>Monitoring&lt;/li>
&lt;li>Other settings like Auto Scaling, IAM, etc&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Add Storage&lt;/li>
&lt;li>Security Settings&lt;/li>
&lt;/ul>
&lt;p>All right, your instance is up and running, and now you can start coding! Not really! That is only the first step of the process, and you will still need to install the web-server, database, framework, etc. After all that is done, you can start coding. The time to perform this process can range from a few hours (for a small project with skilled backend developers) to more than a day for large environments.&lt;/p>
&lt;p>This same process using a backend as a service will be done with a few clicks and take no more than a few minutes.&lt;/p>
&lt;h4 id="example-02--baas-vs-custom-coding-login-feature">Example 02 – BaaS vs. Custom coding Login feature&lt;/h4>
&lt;p>Imagine that after your server setup is ready and you want to develop your application’s first feature. Let’s consider the first feature you will code is a social login to Facebook. I will assume outsourcing development to an offshore company, which will cost $25/hour. This simple task will take around 16 hours and cost $400.&lt;/p>
&lt;p>On the other hand, using a BaaS will allow you to implement the same feature in less than one hour. You will have a saving of 15 hours and $375. Not bad for a simple task implementation!&lt;/p>
&lt;h4 id="example-03--gdpr-security-settings">Example 03 – GDPR security settings&lt;/h4>
&lt;p>GDPR privacy requirements are pretty complicated, and the implementation will demand a lot of engineering effort. The requirements will range from implementing HTTPS for transit data to encrypt server-side data in rest (and several other conditions). The exact amount of engineering hours to fulfill all the elements will depend on the project’s size and complexity, but can easily surpass 100 hours of implementation.&lt;/p>
&lt;p>Outsourcing this implementation to a backend as a service company makes sense, especially for small to medium projects. Because the backend platforms can dilute the investment made to implement GDPR settings among hundreds or thousands of apps, the stake per app will be minimal. A company with a single project will have to offset all the investments under only one application. Even if the app is successful, it will demand much more time to return the investment.&lt;/p>
&lt;h3 id="baas-vs-mbaas">BaaS vs. MBaaS&lt;/h3>
&lt;p>BaaS and MBaaS are pretty much the same things! You can use a backend as a service for web projects or mobile projects. It’s recognized as a mobile backend as a service (MBaaS) or mobile BaaS when used for mobile development.&lt;/p>
&lt;p>Why use a backend as a service?
A BaaS platform will help you to solve two problems:&lt;/p>
&lt;p>Manage and scale cloud infrastructure
Speed up backend development
There are many benefits of using a BaaS cloud, and the reasons to use a backend as a service classifies into business and technical aspects.&lt;/p>
&lt;h2 id="why-use-a-backend-as-a-service">Why use a backend as a service?&lt;/h2>
&lt;p>A BaaS platform will help you to solve two problems:&lt;/p>
&lt;ul>
&lt;li>Manage and scale cloud infrastructure&lt;/li>
&lt;li>Speed up backend development&lt;/li>
&lt;/ul>
&lt;p>There are many benefits of using a BaaS cloud, and the reasons to use a backend as a service classifies into business and technical aspects.&lt;/p>
&lt;h3 id="business-reasons-to-use-a-baas">Business reasons to use a BaaS&lt;/h3>
&lt;p>The business advantages of a backend as a service are mainly related to productivity gains and outsourcing cloud management responsibilities. In particular, for small to medium size projects, you will have substantial benefits using a backend platform. The math is pretty simple; a backend/infrastructure engineer will cost around $80k/year in the USA. Outsourcing part of the work to a third party will allow offsetting this cost.&lt;/p>
&lt;p>The other advantage is delivering faster time to market to a software project. Waiting for several months to provide a software product will kill the market opportunity or make you start behind the competition. So, the business advantages of a BaaS are:&lt;/p>
&lt;ul>
&lt;li>Reduce time to market&lt;/li>
&lt;li>Save money and decrease the cost of development&lt;/li>
&lt;li>Assign fewer backend developers to a project (same results with fewer developers)&lt;/li>
&lt;li>Outsource cloud infrastructure management&lt;/li>
&lt;/ul>
&lt;h3 id="technical-reasons-to-use-a-baas">Technical reasons to use a BaaS&lt;/h3>
&lt;p>Good backend developers are difficult to find and are well-paid professionals. If you find one of them, make sure you use their time wisely and ask them to deliver high-value code. Programming, repetitive activities, and boilerplate code is a waste of time and money. So, it has to be avoided.&lt;/p>
&lt;p>The other advantage of a backend service is that it will let your frontend developers concentrate on what they are best at. That is, delivering frontend code and excellent usability for your application. So, the technical advantages of a BaaS are:&lt;/p>
&lt;ul>
&lt;li>Focus on frontend development&lt;/li>
&lt;li>Excludes redundant stack setup&lt;/li>
&lt;li>No need to program boilerplate code&lt;/li>
&lt;li>Standardize the coding environment&lt;/li>
&lt;li>Let backend developers program high-value lines of code&lt;/li>
&lt;li>Provides ready to use features like authentication, data storage, and search&lt;/li>
&lt;li>Let you clone apps and run testing environments&lt;/li>
&lt;li>Focus on coding business logic rather than boiler plate code&lt;/li>
&lt;li>Has ready to use security settings and backup procedures&lt;/li>
&lt;/ul>
&lt;h2 id="when-to-use-a-backend-as-a-service">When to use a backend as a service?&lt;/h2>
&lt;p>Here are three everyday use cases for using a backend as a service platform:&lt;/p>
&lt;ul>
&lt;li>Making an MVP – Minimum Viable Product&lt;/li>
&lt;li>Stand-alone apps or applications that require a small number of integrations&lt;/li>
&lt;li>Enterprise apps that are not mission-critical&lt;/li>
&lt;/ul>
&lt;p>For these cases, using a BaaS is a no-brain and will save you a lot of time and money.&lt;/p>
&lt;h3 id="advantages-and-disadvantages-of-a-baas">Advantages and Disadvantages of a BaaS&lt;/h3>
&lt;p>Here are the pros and cons of using a backend as a service.&lt;/p>
&lt;p>Advantages of a Backend as a Service&lt;/p>
&lt;ul>
&lt;li>Development speed – It’s super fast&lt;/li>
&lt;li>Development price – It’s really cheap&lt;/li>
&lt;li>It’s serverless, and you don’t need to manage infrastructure&lt;/li>
&lt;/ul>
&lt;p>To know all the benefits of using a BaaS, please read: BaaS – 22 Benefits &lt;a href="https://blog.back4app.com/2019/10/24/what-are-the-benefits-baas-backend-as-a-service/">https://blog.back4app.com/2019/10/24/what-are-the-benefits-baas-backend-as-a-service/&lt;/a> you will enjoy&lt;/p>
&lt;h3 id="disadvantages-of-a-backend-as-a-service">Disadvantages of a Backend as a Service&lt;/h3>
&lt;ul>
&lt;li>Less flexibility in comparison to custom coding&lt;/li>
&lt;li>A lower level of customization in comparison to a custom backend&lt;/li>
&lt;li>Vendor lock-in for closed source platforms&lt;/li>
&lt;/ul>
&lt;h2 id="iaas-x-paas-x-baas">IaaS x PaaS x BaaS&lt;/h2>
&lt;p>Every time you move from IaaS to PaaS and from PaaS to BaaS, you add layers of service (or segments of value) to your application. Here is a simple overview:&lt;/p>
&lt;ul>
&lt;li>IAAS = Data Center + Servers + Storage +Networking&lt;/li>
&lt;li>PAAS = IAAS + Deploy + Manage + Scale&lt;/li>
&lt;li>BAAS = PAAS + Features to Build Backend&lt;/li>
&lt;/ul>
&lt;h2 id="what-features-have-a-backend-as-a-service">What features have a backend as a service?&lt;/h2>
&lt;p>A backend as a service will provide you with features that can be deployed across all types of applications. Here are the most common features of a backend as a service.&lt;/p>
&lt;ul>
&lt;li>Scalable Database (NoSQL or SQL)&lt;/li>
&lt;li>APIs (GraphQL and REST)&lt;/li>
&lt;li>Business Logic via Cloud Code Functions&lt;/li>
&lt;li>User authentication&lt;/li>
&lt;li>Social Integration (Facebook, LinkedIn, Twitter, etc.)&lt;/li>
&lt;li>Email Verification&lt;/li>
&lt;li>Push Notifications&lt;/li>
&lt;li>Geolocation&lt;/li>
&lt;li>Database Graphical User Interface (GUI)&lt;/li>
&lt;li>Logs&lt;/li>
&lt;li>CDN and Cache&lt;/li>
&lt;li>Infrastructure (Security settings, auto-scaling, data backup, DB optimization)&lt;/li>
&lt;/ul>
&lt;h2 id="how-does-a-baas-architecture-look-like">How does a BaaS architecture look like?&lt;/h2>
&lt;p>Generally speaking, a mobile backend as a service architecture is divided into three different layers.&lt;/p>
&lt;p>The first layer is the foundation and contains the database servers. A database cluster will have at least two servers to replicate data and a backup routine to retrieve data.&lt;/p>
&lt;p>The second layer is the application cluster and contains multiple servers to process requests. The quantity of servers fluctuates throughout the time of the day, and auto-scaling procedures are necessary to fulfill the group with the correct amount of servers.&lt;/p>
&lt;p>The third layer connects the application servers to the Internet, and it’s composed of load balancers and CDNs.&lt;/p>
&lt;p>&lt;img src="images/2.png" alt="2">&lt;/p>
&lt;h2 id="what-types-of-projects-run-best-on-a-backend-as-a-service">What types of projects run best on a Backend as a Service?&lt;/h2>
&lt;ul>
&lt;li>Real-time applications (chat, messaging apps)&lt;/li>
&lt;li>Transportation apps (similar to Uber)&lt;/li>
&lt;li>Social-network type apps&lt;/li>
&lt;li>Ecommerce apps&lt;/li>
&lt;li>Music or Video streaming apps&lt;/li>
&lt;li>Games&lt;/li>
&lt;/ul>
&lt;h2 id="baas-providers-and-features">BaaS Providers and features&lt;/h2>
&lt;p>Refer to &lt;a href="https://blog.back4app.com/backend-as-a-service-baas/">https://blog.back4app.com/backend-as-a-service-baas/&lt;/a>&lt;/p>
&lt;h3 id="baas-providers-comparison">BaaS Providers Comparison&lt;/h3>
&lt;p>&lt;img src="images/3.png" alt="">&lt;/p>
&lt;p>&lt;img src="images/4.png" alt="4">&lt;/p>
&lt;p>&lt;img src="images/5.png" alt="5">&lt;/p>
&lt;p>&lt;img src="images/6.png" alt="6">&lt;/p></description></item><item><title>Topics: 12 Factor App Principles and Cloud-Native Microservices</title><link>/topics/cloud-native/12-factor-apps/12-factor-app-principles-and-cloud-native-microservices/</link><pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate><guid>/topics/cloud-native/12-factor-apps/12-factor-app-principles-and-cloud-native-microservices/</guid><description>
&lt;p>&lt;img src="images/12-factor-app-principles.png" alt="img">&lt;/p>
&lt;p>12-factor app is a methodology or set of principles for building the scalable and performant, independent, and most resilient enterprise applications. It establishes the general principles and guidelines for creating robust enterprise applications. 12-factor app principles got very popular as it aligns with Microservice principles.&lt;/p>
&lt;h2 id="the-12-factor-principles">The 12-Factor Principles&lt;/h2>
&lt;ul>
&lt;li>Codebase (One codebase tracked in revision control, many deploys)&lt;/li>
&lt;li>Dependencies (Explicitly declare and isolate the dependencies)&lt;/li>
&lt;li>Config (Store configurations in an environment)&lt;/li>
&lt;li>Backing Services (treat backing resources as attached resources)&lt;/li>
&lt;li>Build, release, and Run (Strictly separate build and run stages)&lt;/li>
&lt;li>Processes (execute the app as one or more stateless processes)&lt;/li>
&lt;li>Port Binding (Export services via port binding)&lt;/li>
&lt;li>Concurrency (Scale out via the process model)&lt;/li>
&lt;li>Disposability (maximize the robustness with fast startup and graceful shutdown)&lt;/li>
&lt;li>Dev/prod parity (Keep development, staging, and production as similar as possible)&lt;/li>
&lt;li>Logs (Treat logs as event streams)&lt;/li>
&lt;li>Admin processes (Run admin/management tasks as one-off processes)&lt;/li>
&lt;/ul>
&lt;h2 id="1-codebase-one-codebase-tracked-in-revision-control-many-deploys">1. Codebase (One Codebase Tracked In Revision Control, Many Deploys)&lt;/h2>
&lt;p>12-factor app advocates that every application should have its own codebase (repos). Multiple codebases for multiple versions must be avoided. Please do note that having branches would be fine. I.e. For all the deployment environments there should be only one repo but not multiple.&lt;/p>
&lt;p>Multiple apps sharing the same code are a violation of the twelve-factor. Here you should opt-in for shared libraries.&lt;/p>
&lt;p>From the 12-factor app perspective app, deploy meaning the running instance of an app like production, staging, QA, etc. Additionally, every developer has a copy of the app running in their local development environment, each of which also qualifies as a deploy.&lt;/p>
&lt;p>Different versions (the version is like a code change that is available in one environment but not in other) may be active in multiple deploys.&lt;/p>
&lt;ul>
&lt;li>Microservices: In Microservices, every service should have its own codebase. Having an independent codebase helps you to easy CI/CD process for your applications.&lt;/li>
&lt;/ul>
&lt;p>Twelve-factor app advocates of not sharing the code between the application. If you need to share you need to build a library and make it as a dependency and manage through package repository like maven.&lt;/p>
&lt;h2 id="2-dependencies-explicitly-declare-and-isolate-the-dependencies">2. Dependencies (Explicitly Declare and Isolate the Dependencies)&lt;/h2>
&lt;p>It talks about managing the dependencies externally using dependency management tools instead of adding them to your codebase.&lt;/p>
&lt;p>From the perspective of the Java, you can think of Gradle as a dependency manager. You will mention all the dependencies in build.gradle file and your application will download all the mentioned dependencies from maven repository or various other repositories.&lt;/p>
&lt;p>You also need to consider the dependencies from the operating system/ execution environment perspective as well.&lt;/p>
&lt;p>Microservices: All the application packages will be managed through package managers like sbt, maven.&lt;/p>
&lt;ul>
&lt;li>In non-containerized environments, you can go for configuration management tools like chef, ansible, etc. to install system-level dependencies.&lt;/li>
&lt;li>For a containerized environment, you can go for dockerfile.&lt;/li>
&lt;/ul>
&lt;h2 id="3-config-store-configurations-in-an-environment">3. Config (Store Configurations In an Environment&lt;/h2>
&lt;p>Anything that varies between the deployment environments is considered as configuration. This includes:&lt;/p>
&lt;ul>
&lt;li>Database connections and credentials, system integration endpoints&lt;/li>
&lt;li>Credentials to external services such as Amazon S3 or Twitter or any other external apps&lt;/li>
&lt;li>Application-specific information like IP Addresses, ports, and hostnames, etc.&lt;/li>
&lt;/ul>
&lt;p>You should not hardcode any configuration values as constants in the codebase. This is a direct violation of 12-factor app principles.&lt;/p>
&lt;p>12-factor app principles suggest saving the configuration values in the environment variables.&lt;/p>
&lt;p>It advocates the strict separation between the code and configurations. The code must be the same irrespective of where the application being deployed.&lt;/p>
&lt;p>As per &amp;ldquo;config&amp;rdquo;, what varies for the environment to the environment must be moved to configurations and managed via environment variables.&lt;/p>
&lt;ul>
&lt;li>Microservices: Externalize the configurations from the application. In a microservice service environment, you can manage the configurations for your applications from a source control like git (spring-cloud-config) and use the environment variables to not to maintain the sensitive information in the source control.&lt;/li>
&lt;/ul>
&lt;h2 id="4-backing-services-treat-backing-resources-as-attached-resources">4. Backing Services (Treat Backing Resources as Attached Resources)&lt;/h2>
&lt;p>As per 12 factor app principles, a backing service is an application/service the app consumes over the network as part of its normal operation.&lt;/p>
&lt;p>Database, Message Brokers, any other external systems that the app communicates is treated as Backing service.&lt;/p>
&lt;p>12-factor app can automatically swap the application from one provider to another without making any further modifications to the code base. Let us say, you would like to change the database server from MySQL to Aurora. To do so, you should not make any code changes to your application. Only configuration change should be able to take care of it.&lt;/p>
&lt;ul>
&lt;li>Microservices: In a microservice ecosystem, anything external to service is treated as attached resource. The resource can be swapped at any given point of time without impacting the service.&lt;/li>
&lt;/ul>
&lt;p>By following the interfaced based programming allow to swap the provider dynamically without impact on the system. Plug-in based implementation also helps you to support multiple providers.&lt;/p>
&lt;h2 id="5-build-release-and-run-strictly-separate-build-and-run-stages">5. Build, Release, and Run (Strictly Separate Build and Run Stages)&lt;/h2>
&lt;p>The application must have a strict separation between the build, release, and run stages. Let us understand each stage in more detail.&lt;/p>
&lt;ul>
&lt;li>Build stage: transform the code into an executable bundle/ build package.&lt;/li>
&lt;li>Release stage: get the build package from the build stage and combines with the configurations of the deployment environment and make your application ready to run.&lt;/li>
&lt;li>Run stage: It is like running your app in the execution environment.&lt;/li>
&lt;/ul>
&lt;p>Microservices: You can use CI/CD tools to automate the builds and deployment process. Docker images make it easy to separate the build, release, and run stages more efficiently.&lt;/p>
&lt;h2 id="6-processes-execute-the-app-as-one-or-more-stateless-processes">6. Processes (Execute the App as One or More Stateless Processes)&lt;/h2>
&lt;p>The app is executed inside the execution environment as a process. An app can have one or more instances/processes to meet the user/customer demands.&lt;/p>
&lt;p>As per 12-factor principles, the application should not store the data in in-memory and it must be saved to a store and use from there. As far as the state concern, your application should store the state in the database instead of in memory of the process.&lt;/p>
&lt;p>Avoid using sticky sessions, using sticky sessions are a violation of 12-factor app principles. If you would store the session information, you can choose redis or memcached or any other cache provider based on your requirements.&lt;/p>
&lt;p>By following these, your app can be highly scalable without any impact on the system&lt;/p>
&lt;ul>
&lt;li>Microservices: By adopting the stateless nature of REST, your services can be horizontally scaled as per the needs with zero impact. If your system still requires to maintain the state use the attached resources (redis, Memcached, or datastore) to store the state instead of in-memory.&lt;/li>
&lt;/ul>
&lt;h2 id="7-port-binding-export-services-via-port-binding">7. Port Binding (Export Services Via Port Binding)&lt;/h2>
&lt;p>The twelve-factor app is completely self-contained and doesn&amp;rsquo;t rely on runtime injection of a webserver into the execution environment to create a web-facing service. The web app exports HTTP as a service by binding to a port, and listening to requests coming in on that port.&lt;/p>
&lt;p>In short, this is all about having your application as a standalone instead of deploying them into any of the external web servers.&lt;/p>
&lt;ul>
&lt;li>Microservices: Spring boot is one example of this one. Spring boot by default comes with embedded tomcat, jetty, or undertow.&lt;/li>
&lt;/ul>
&lt;h2 id="8-concurrency-scale-out-via-the-process-model">8. Concurrency (Scale Out Via the Process Model)&lt;/h2>
&lt;p>This talks about scaling the application. Twelve-factor app principles suggest to consider running your application as multiple processes/instances instead of running in one large system. You can still opt-in for threads to improve the concurrent handling of the requests.&lt;/p>
&lt;p>In a nutshell, twelve-factor app principles advocate to opt-in for horizontal scaling instead of vertical scaling.&lt;/p>
&lt;p>(vertical scaling- Add additional hardware to the system&lt;/p>
&lt;p>Horizontal scaling - Add additional instances of the application)&lt;/p>
&lt;ul>
&lt;li>Microservices: By adopting the containerization, applications can be scaled horizontally as per the demands.&lt;/li>
&lt;/ul>
&lt;h2 id="9-disposability-maximize-the-robustness-with-fast-startup-and-graceful-shutdown">9. Disposability (Maximize the Robustness with Fast Startup and Graceful Shutdown)&lt;/h2>
&lt;p>The twelve-factor app&amp;rsquo;s processes are disposable, meaning they can be started or stopped at a moment&amp;rsquo;s notice. When the application is shutting down or starting, an instance should not impact the application state.&lt;/p>
&lt;p>Graceful shutdowns are very important. The system must ensure the correct state.&lt;/p>
&lt;p>The system should not get impacted when new instances are added or takedown the existing instances as per need. This is also known as system disposability.&lt;/p>
&lt;p>Systems do crash due to various reasons. the system should ensure that the impact would be minimal and the application should be stored in a valid state.&lt;/p>
&lt;ul>
&lt;li>Microservices: By adopting the containerization into the deployment process of microservices, your application implicitly follows this principle at a maximum extent. Docker containers can be started or stopped instantly. Storing request, state, or session data in queues or other backing services ensures that a request is handled seamlessly in the event of a container crash.&lt;/li>
&lt;/ul>
&lt;h2 id="10-devprod-parity-keep-development-staging-and-production-as-similar-as-possible">10. Dev/Prod Parity (Keep Development, Staging, and Production as Similar as Possible)&lt;/h2>
&lt;p>The twelve-factor methodology suggests keeping the gap between development and production environment as minimal as possible. This reduces the risks of showing up bugs in a specific environment.&lt;/p>
&lt;p>The twelve-factor developer resists the urge to use different backing services between development and production.&lt;/p>
&lt;ul>
&lt;li>Microservices: This is an inherent feature of the Microservices that is run using the containerization techniques.&lt;/li>
&lt;/ul>
&lt;h2 id="11-logs-treat-logs-as-event-streams">11. Logs (Treat Logs as Event Streams)&lt;/h2>
&lt;p>Logs become paramount in troubleshooting the production issues or understanding the user behavior. Logs provide visibility into the behavior of a running application.&lt;/p>
&lt;p>Twelve-factor app principles advocate separating the log generation and processing the log&amp;rsquo;s information. From the application logs will be written as a standard output and the execution environment takes care of capture, storage, curation, and archival of such stream should be handled by the execution environment.&lt;/p>
&lt;ul>
&lt;li>Microservices: In Microservices, observability is the first-class citizen. Observability can be achieved through using APM tools (ELK, Newrelic, and other tools) or log aggregations tools like Splunk, logs, etc.&lt;/li>
&lt;/ul>
&lt;p>By following the above-mentioned guidelines all you need is to debug an issue is to go to the central dashboard of your tool and search for it.&lt;/p>
&lt;h2 id="12-admin-processes-run-adminmanagement-tasks-as-one-off-processes">12. Admin Processes (Run Admin/Management Tasks as One-Off Processes)&lt;/h2>
&lt;p>There is a number of one-off processes as part of the application deployment like data migration, executing one-off scripts in a specific environment.&lt;/p>
&lt;p>Twelve-factor principles advocates for keeping such administrative tasks as part of the application codebase in the repository. By doing so, one-off scripts follow the same process defined for your codebase.&lt;/p>
&lt;p>Ensure one-off scripts are automated so that you don&amp;rsquo;t need to worry about executing them manually before releasing the build.&lt;/p>
&lt;p>Twelve-factor principles also suggest using the built-in tool of the execution environment to run those scripts on production servers.&lt;/p>
&lt;ul>
&lt;li>Microservices: Containerization also helps here to run the one-off processes as a task and shutdown automatically one done with the implementation.&lt;/li>
&lt;/ul>
&lt;p>That&amp;rsquo;s all for today. Hope you have enjoyed the article. Please share your thoughts or ideas or improvements in the below comments box.&lt;/p></description></item><item><title>Topics: Spring 5.0 Microservice 2nd - Twelve-Factor Apps</title><link>/topics/cloud-native/12-factor-apps/spring-5.0-microservice-2nd-twelve-factor-apps/</link><pubDate>Sun, 30 Aug 2020 00:00:00 +0000</pubDate><guid>/topics/cloud-native/12-factor-apps/spring-5.0-microservice-2nd-twelve-factor-apps/</guid><description>
&lt;h2 id="1-single-code-base">1. Single code base&lt;/h2>
&lt;p>&lt;img src="images/single-code-base.png" alt="">&lt;/p>
&lt;p>Extending the same philosophy for microservices, each microservice should have its own code base, and this code base is not shared with any other microservice. It also means that one microservice will have exactly one code base.&lt;/p>
&lt;h2 id="2-bundle-dependencies">2. Bundle dependencies&lt;/h2>
&lt;h2 id="3-externalizing-configurations">3. Externalizing configurations&lt;/h2>
&lt;p>The Externalize configurations principle gives you an advice to externalize all configuration parameters from the code. An application&amp;rsquo;s configuration parameters vary between environments such as support email IDs or URL of an external system, username, passwords, queue name, and more. These will be different for development, testing, and production. All service configurations should be externalized&lt;/p>
&lt;p>&lt;img src="images/externalizing-configurations.png" alt="">&lt;/p>
&lt;h2 id="4-backing-services-are-addressable">4. Backing services are addressable&lt;/h2>
&lt;p>All backing services should be accessible through an addressable URL. All services need to talk to some external resources during the life cycle of their execution. For example, they could be listening to or sending messages to a messaging system, sending an email, or persisting data to a database. All these services should be reachable through a URL without complex communication requirements&lt;/p>
&lt;p>&lt;img src="images/backing-services-are-addressable.png" alt="">&lt;/p>
&lt;h2 id="5-isolation-between-build-release-and-run">5. Isolation between build, release, and run&lt;/h2>
&lt;p>&lt;img src="images/isolation-between-build-release-and-run.png" alt="">&lt;/p>
&lt;h2 id="6-stateless-shared-nothing-processes">6. Stateless, shared nothing processes&lt;/h2>
&lt;h2 id="7-expose-services-through-port-bindings">7. Expose services through port bindings&lt;/h2>
&lt;p>A Twelve-Factor App ideally does not relay on an external web server. A HTTP listener, such as Tomcat, Jetty, and more, has to be embedded in the service or application itself.&lt;/p>
&lt;h2 id="8-concurrency-for-scale-out">8. Concurrency for scale out&lt;/h2>
&lt;p>In the microservices world, services are designed for a scale out rather than scale up.&lt;/p>
&lt;h2 id="9-disposability-with-minimal-overhead">9. Disposability, with minimal overhead&lt;/h2>
&lt;p>In the microservices context, in order to achieve full automation, it is extremely important to keep the size of the application as thin as possible, with minimal startup and shutdown times. Microservices should also consider lazy loading of objects and data.&lt;/p>
&lt;h2 id="10-development-production-parity">10. Development, production parity&lt;/h2>
&lt;p>The development, production parity principle states the importance of keeping the development and production environments as identical as possible. For example, let&amp;rsquo;s consider an application with multiple services or processes, such as a job scheduler service, cache services, or one or more application services. In a development environment, we tend to run all of them on a single machine. Whereas, in production, we will facilitate independent machines to run each of these processes.&lt;/p>
&lt;h2 id="11-externalizing-logs">11. Externalizing logs&lt;/h2>
&lt;p>If the I/Os are not fast enough in a given infrastructure, they could create a bottleneck. The solution to this is to use a centralized logging framework. &lt;strong>Splunk, greylog, Logstash, Logplex, Loggly&lt;/strong> are some examples of log shipping and analysis tools. The recommended approach is to ship logs to a central repository by tapping the logback appenders and write to one of the shipper&amp;rsquo;s endpoints.&lt;/p>
&lt;p>&lt;img src="images/externalizing-logs.png" alt="">&lt;/p>
&lt;h2 id="12-package-admin-processes">12. Package admin processes&lt;/h2>
&lt;p>Apart from application requests, most of the applications provision for admin tasks. This principle advices you to target the same release and an identical environment as the long running processes runs to perform these activities. Admin code should also be packaged along with the application code.&lt;/p></description></item></channel></rss>